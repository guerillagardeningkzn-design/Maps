<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Table Mountain 3D Terrain Map</title>

<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>

<style>
html, body {
    margin: 0;
    padding: 0;
    height: 100%;
    background: #0d1117;
    font-family: Arial, sans-serif;
}

#map {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 100%;
}

.info {
    position: absolute;
    top: 15px;
    left: 15px;
    background: rgba(0, 0, 0, 0.75);
    color: #ffffff;
    padding: 10px 14px;
    border-radius: 8px;
    font-size: 14px;
}
</style>
</head>

<body>

<div id="map"></div>
<div class="info">
    Table Mountain â€“ Cape Town ðŸ‡¿ðŸ‡¦<br>
    3D Buildings + Square Zones + Cloud Obscure
</div>
<script>
const centerLng = 18.4241;
const centerLat = -33.9628;
const sideMeters = 50; // Side length in meters (perimeter ~200m)
const rings = 1; // Grid size: 3Ã—3 = 9 squares (center + 8 neighbors)

const metersPerDegLat = 111319;
const latRad = centerLat * Math.PI / 180;
const metersPerDegLng = 111319 * Math.cos(latRad);

const dLat = sideMeters / metersPerDegLat;
const dLng = sideMeters / metersPerDegLng;

const features = [];
for (let i = -rings; i <= rings; i++) {
    for (let j = -rings; j <= rings; j++) {
        const minLng = centerLng + i * dLng;
        const minLat = centerLat + j * dLat;
        const maxLng = minLng + dLng;
        const maxLat = minLat + dLat;
        const coords = [
            [minLng, minLat],
            [maxLng, minLat],
            [maxLng, maxLat],
            [minLng, maxLat],
            [minLng, minLat]
        ];
        features.push({
            type: 'Feature',
            properties: {},
            geometry: {
                type: 'Polygon',
                coordinates: [coords]
            }
        });
    }
}

const geoJSON = {
    type: 'FeatureCollection',
    features: features
};

const map = new maplibregl.Map({
    container: 'map',
    center: [centerLng, centerLat],
    zoom: 17.5, // Slightly lower than 18 to ensure tiles exist reliably
    pitch: 60,
    bearing: -20,
    antialias: true,
    style: {
        version: 8,
        sources: {
            basemap: {
                type: 'raster',
                tiles: [
                    'https://tiles.stadiamaps.com/tiles/stamen_toner/{z}/{x}/{y}{r}.png'
                ],
                tileSize: 256,
                attribution: '&copy; <a href="https://stadiamaps.com/" target="_blank">Stadia Maps</a> &copy; <a href="https://stamen.com/" target="_blank">Stamen Design</a> &copy; <a href="https://openmaptiles.org/" target="_blank">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            },
            openmaptiles: {
                type: 'vector',
                url: 'https://demotiles.maplibre.org/tiles/tiles.json'
            }
        },
        layers: [
            {
                id: 'basemap-layer',
                type: 'raster',
                source: 'basemap'
            }
        ]
    }
});

map.addControl(new maplibregl.NavigationControl());

map.on('load', () => {

    // Add 3D buildings
    map.addLayer({
        id: '3d-buildings',
        source: 'openmaptiles',
        'source-layer': 'building',
        type: 'fill-extrusion',
        minzoom: 13,
        paint: {
            'fill-extrusion-color': [
                'interpolate',
                ['linear'],
                ['get', 'render_height'],
                0, '#aaaaaa',
                100, '#ffcc66'
            ],
            'fill-extrusion-height': [
                'coalesce',
                ['get', 'render_height'],
                20
            ],
            'fill-extrusion-base': 0,
            'fill-extrusion-opacity': 0.9
        }
    });

    // Calculate bounds from all vertices (the 3Ã—3 grid)
    const bounds = new maplibregl.LngLatBounds();
    geoJSON.features.forEach(feature => {
        feature.geometry.coordinates[0].forEach(coord => {
            bounds.extend(coord);
        });
    });

    // Create obscuring GeoJSON with hole in the center (the 3Ã—3 area)
    const obscureGeoJSON = {
        type: 'FeatureCollection',
        features: [{
            type: 'Feature',
            properties: {},
            geometry: {
                type: 'Polygon',
                coordinates: [
                    [ // outer ring (counterclockwise)
                        [-180, -85],
                        [-180, 85],
                        [180, 85],
                        [180, -85],
                        [-180, -85]
                    ],
                    [ // inner hole (clockwise) = the visible sector
                        [bounds.getWest(), bounds.getSouth()],
                        [bounds.getEast(), bounds.getSouth()],
                        [bounds.getEast(), bounds.getNorth()],
                        [bounds.getWest(), bounds.getNorth()],
                        [bounds.getWest(), bounds.getSouth()]
                    ]
                ]
            }
        }]
    };

    // Load cloud pattern image (you can replace this URL with any cloud texture you prefer)
    map.loadImage('https://img.freepik.com/free-photo/abstract-texture-background_23-2151897961.jpg', (error, image) => {
        if (error) {
            console.error('Failed to load cloud image:', error);
            return;
        }
        map.addImage('cloud-pattern', image);

        map.addSource('obscure', {
            type: 'geojson',
            data: obscureGeoJSON
        });

        map.addLayer({
            id: 'obscure-fill',
            type: 'fill',
            source: 'obscure',
            paint: {
                'fill-pattern': 'cloud-pattern',
                'fill-opacity': 0.85
            }
        }, '3d-buildings'); // Insert before buildings so it doesn't cover them
    });

    // Optional: light fog for extra atmospheric effect
    map.setFog({
        range: [0.5, 12],
        color: 'rgb(240, 240, 245)',
        'horizon-blend': 0.12
    });

    // Add the 9 square zones
    map.addSource('squares', {
        type: 'geojson',
        data: geoJSON
    });

    map.addLayer({
        id: 'square-fill',
        type: 'fill',
        source: 'squares',
        paint: {
            'fill-color': '#00ff00',
            'fill-opacity': 0.25
        }
    });

    map.addLayer({
        id: 'square-line',
        type: 'line',
        source: 'squares',
        paint: {
            'line-color': '#000000',
            'line-width': 1.5
        }
    });

    // Lock the map to the 3Ã—3 sector bounds
    map.setMaxBounds(bounds);

    // Fit view to the sector with some padding (helps with pitch)
    map.fitBounds(bounds, {
        padding: 60,
        duration: 0
    });

    // Disable panning (so user stays in this one location/sector)
    // but allow rotation and zoom
    map.dragPan.disable();
    map.keyboard.disable(); // prevents arrow-key panning
    // Rotation and zoom remain enabled by default
});
</script>

</body>
</html>
